#!/bin/bash
# vim: ft=sh
#
# Script to scan files for sensitive content.
# This script expects to receive a list of files to check as arguments.

# --- Configuration ---
# Add keywords or patterns to block here. Use caution with generic words.
# It's recommended to use specific identifiers, project names, hostnames etc.
# Use egrep syntax if needed (though currently using grep -F for fixed strings).
BLOCKED_KEYWORDS=(
	"secret_key"
	"_secret"
	"gusto"
	"payroll-"
	"BEGIN RSA PRIVATE KEY"
)

# This file's location in Bash 
HOOK_PATH=".scripts/scan-for-sensitive-content"
CASE_INSENSITIVE=true
DEBUG=false

# Default exit code: 0 (i.e. no sensitive content found)
exit_code=0
found_keywords=()

# Set up grep options
grep_opts="-F" # Fixed string matching is safer and often sufficient
if $CASE_INSENSITIVE; then
	if echo "test" | grep -q -i "TEST"; then
		grep_opts="$grep_opts -i"
	else
		echo "Warning: Your grep version might not support -i for case-insensitivity." >&2
	fi
fi

grep_find_opts="$grep_opts" # Options for the actual blocking check
if $DEBUG; then
	grep_find_opts="$grep_find_opts -n" # Show line numbers when reporting found keywords
fi
grep_check_opts="$grep_opts -q" # Use -q for the initial silent check

# This initial message is helpful even without full debug
echo "Scanning for sensitive content..." >&2

# Files are passed as arguments
files_to_check=("$@")

if $DEBUG; then
    files_list_debug=$(printf "%s;" "${files_to_check[@]}")
    echo "DEBUG: Files received as arguments: [$files_list_debug]" >&2
fi

# Exit early if no files to check
if [ ${#files_to_check[@]} -eq 0 ]; then
    if $DEBUG; then
        echo "DEBUG: No files to check. Exiting." >&2
    else
        # Clear the processing line if no files were found
        printf "\033[A\033[2K"
        echo -e "\033[32m✔\033[0m  No files to scan"
    fi
    exit 0
fi

$DEBUG && echo "DEBUG: Starting scan for keywords in files..." >&2;
for file in "${files_to_check[@]}"; do
    # Exclude the hook script itself from being scanned
    if [[ "$file" == "$HOOK_PATH" ]]; then
        continue
    fi

    $DEBUG && echo "DEBUG:   Checking file: [$file]" >&2;
    
    # Check if file exists
    if [ -f "$file" ]; then
        $DEBUG && echo "DEBUG:     File exists. Scanning content..." >&2;
        
        for keyword in "${BLOCKED_KEYWORDS[@]}"; do
            # Use grep -q for a quick check first
            if grep $grep_check_opts -- "$keyword" "$file"; then
                # Found a keyword, now get details if needed and report
                if $DEBUG; then
                    match_details=$(grep $grep_find_opts -- "$keyword" "$file" | head -n 5) # Limit output lines
                    echo "Found blocked keyword '$keyword' in file '$file':" >&2
                    echo "--- Matched Lines ---" >&2
                    echo "$match_details" >&2
                    echo "---------------------" >&2
                fi
                found_keywords+=("'$keyword' in $file")
                exit_code=1
            fi
        done
    else
        $DEBUG && echo "DEBUG: Skipping scan for '$file' (file not found)" >&2;
    fi
done

$DEBUG && echo "DEBUG: Finished scanning files." >&2;

if [ $exit_code -ne 0 ]; then
    echo -en "\033[31m"
    echo "error: sensitive content detected:" >&2
    printf "%s\n" "${found_keywords[@]}" | sort -u | sed 's/^/  - /' >&2
    echo -en "\033[0m"
elif $DEBUG; then
    echo "DEBUG: No blocked keywords found in the scanned content." >&2
else
    # Clear the processing line if no errors were found
    printf "\033[A\033[2K"
    echo -e "\033[32m✔\033[0m  Content scan passed"
fi

exit $exit_code
